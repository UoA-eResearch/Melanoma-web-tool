<!DOCTYPE html>
<html lang="en">

<head>
    <title>Melanoma</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <style>
        body {
            background-color: #000;
            color: #fff;
            padding: 0;
            margin: 0;
            font-weight: bold;
            overflow: hidden;
            font-family: sans-serif;
            font-size: 12px;
            text-align: center;
        }

        #info {
            background-color: #000;
            position: absolute;
            width: 100%;
            top: 0px;
            padding: 5px;
            z-index: 999;
        }

        a {
            color: #0080ff;
        }

        b {
            color: orange
        }

        .sidebar {
            position: fixed;
            z-index: 999;
            right: 0;
            top: 50px;
            width: 40%;
            height: 80%;
            overflow: auto;
            background-color: #f5f5f5;
            color: black;
            padding: 20px;
            box-sizing: border-box;
            border-radius: 10px;
        }

        .label {
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            border: 1px solid #fff;
            padding: 2px;
        }
    </style>
</head>

<body>
    <div id="info">Controls: left mouse button to rotate, right mouse button to pan. Mouse wheel to zoom. Click to freeze hovering. Double click
        to focus</div>
    <div id="container"></div>
    <div id="sidebar" class="sidebar show">
        <h3>Statistics</h3>
        <table class="table table-hover">
            <thead>
                <th>Code</th>
                <th>Nodefield</th>
                <th># Cases</th>
                <th>Mean Drainage % </th>
                <th>95%CI</th>
            </thead>
            <tbody id="tbody">
                <tr><td colspan="5">Hover over an element to populate this table</td></tr>
            </tbody>
        </table>
        <div>
            TIS = Triangular Intermuscular Space
        </div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
            }
        }
    </script>
    <script defer type="module">

        import $ from 'https://cdn.jsdelivr.net/npm/jquery@3.7.1/+esm'
        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import WebGL from 'three/addons/capabilities/WebGL.js';
        import { ArcballControls } from 'three/addons/controls/ArcballControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        /*
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        */

        let container = document.getElementById('container')

        let stats;

        let camera, cameraTarget, scene, renderer, controls, labelRenderer, raycaster, INTERSECTED;

        let selectable = [];

        let frozen = false;

        var offset = new THREE.Vector3(-270, -200, 900);

        const pointer = new THREE.Vector2();

        init();

        function addLabel(text, position, additional_class="landmark") {
            const labelDiv = document.createElement('div');
            labelDiv.className = `label ${additional_class}`;
            labelDiv.textContent = text;
            const label = new CSS2DObject(labelDiv);
            label.position.copy(position);
            scene.add(label);
            return label;
        }

        function addSphere(position) {
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(10, 32, 32), new THREE.MeshPhongMaterial({color: 0x00ff00}));
            sphere.position.copy(position)
            scene.add(sphere);
            return sphere;
        }

        let tooltip = addLabel("Element name", new THREE.Vector3(0, 0, 0), "tt");
        tooltip.visible = false;

        let lymphs = await fetch("lymphs_positions.json").then(response => response.json());
        console.log(lymphs);
        window.lymph_lookup = {}
        for (var l of lymphs) {
            var position = new THREE.Vector3(l.position[0], l.position[1], l.position[2]).add(offset);
            let sphere = addSphere(position);
            let label = addLabel(l.label, position, "lymph");
            lymph_lookup[l.label] = {
                "sphere": sphere,
                "label": label
            }
        }

        let data_elements;
        data_elements = await fetch("src/data/data_elements.json").then(response => response.json());
        console.log(data_elements)

        function init() {

            if (!WebGL.isWebGLAvailable()) {
                const warning = WebGL.getWebGLErrorMessage();
                container.appendChild(warning);
                return;
            }

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000);
            window.camera = camera;
            camera.position.set(1496.96865501004, 3213.1316867226697, -232.08816356744805);
            camera.up = new THREE.Vector3(0,0,1);

            scene = new THREE.Scene();

            const loader = new GLTFLoader();

            loader.load("scene.glb", (root) => {
                console.log(root)
                root = root.scene.children[0];
                console.log(root)
                for (var i in root.children) {
                    var child = root.children[i];
                    child.geometry.computeVertexNormals()
                    if (child.name == "Lines") {
                        console.log(child)
                        const material = new THREE.LineBasicMaterial({color: 0x000000});
                        const mesh = new THREE.LineSegments(child.geometry, material);
                        mesh.position.add(offset);
                        root.children[i] = mesh;
                    } else {
                        child.material = new THREE.MeshPhongMaterial({
                            color: "#E5B27F",
                            specular: "#33334C",
                            opacity: .5,
                            transparent: true,
                            shininess: 20,
                            flatShading: false,
                            side: THREE.DoubleSide
                        });
                        selectable.push(child);
                    }
                }
                root.position.add(offset);
                scene.add(root);
            });

            // lights

            const dirLight1 = new THREE.DirectionalLight(0xffffff, 3);
            dirLight1.position.set(1, 1, 1);
            scene.add(dirLight1);

            const ambientLight = new THREE.AmbientLight(0x404040, 10);
            scene.add(ambientLight);

            raycaster = new THREE.Raycaster();

            // renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            document.body.appendChild(labelRenderer.domElement);

            //controls
            controls = new ArcballControls(camera, labelRenderer.domElement, scene);
            //controls.addEventListener('change', render);
            controls.setGizmosVisible(false);
            window.controls = controls;

            //controls.minDistance = 1
            //controls.maxDistance = 2000
            // axes
            //const axesHelper = new THREE.AxesHelper(250);
            //scene.add(axesHelper);
            // stats
            stats = new Stats();
            container.appendChild(stats.dom);
            window.addEventListener('mousemove', onPointerMove );
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            let drag = false;
            document.addEventListener('mousedown', () => drag = false);
            document.addEventListener('mousemove', () => drag = true);
            document.addEventListener('mouseup', function() {
                if (!drag) {
                    frozen = !frozen;
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerMove( event ) {
            pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        function animate() {
            render();
            stats.update();
        }

        function render() {
            if (!frozen) {
                raycaster.setFromCamera( pointer, camera );
                const intersects = raycaster.intersectObjects( selectable, true );
                if ( intersects.length > 0 ) {
                    if ( INTERSECTED != intersects[ 0 ].object ) {
                        if ( INTERSECTED ) INTERSECTED.material.emissive?.setHex( INTERSECTED.currentHex );
                        INTERSECTED = intersects[ 0 ].object;
                        INTERSECTED.currentHex = INTERSECTED.material.emissive?.getHex();
                        INTERSECTED.material.emissive?.setHex( 0xff0000 );
                        if (data_elements) {
                            $("#sidebar h3").text("Statistics for " + INTERSECTED.name.replace(/_/g, " "));
                            $("#tbody").empty()
                            for (var lymph_objects of Object.values(lymph_lookup)) {
                                lymph_objects.sphere.visible = false;
                                lymph_objects.label.visible = false;
                            }
                            var rows = data_elements[INTERSECTED.name]
                            if (!rows) {
                                rows = data_elements[INTERSECTED.name.replace(/_/g, " ")]
                            }
                            if (tooltip) {
                                tooltip.position.copy(intersects[0].point);
                                tooltip.element.textContent = INTERSECTED.name.replace(/_/g, " ");
                                tooltip.visible = true;
                            }
                            if (!rows) {
                                console.warn(INTERSECTED.name)
                                $("#tbody").append(`<tr><td colspan="5">No data available</td></tr>`)
                                return;
                            }
                            for (var d of rows) {
                                if (lymph_lookup[d.code]) {
                                    lymph_lookup[d.code].sphere.visible = true;
                                    lymph_lookup[d.code].label.visible = true;
                                    lymph_lookup[d.code].label.element.textContent = `${d.code} (${d.percentage.trim()}%)`;
                                    let pct = parseFloat(d.percentage) / 50
                                    lymph_lookup[d.code].sphere.scale.setScalar(pct).clampScalar(.5, 50);
                                }
                                $("#tbody").append(`<tr><td>${d.code}</td><td>${d.name}</td><td>${d.count}</td><td>${d.percentage}</td><td>${d.CI}</td></tr>`)
                            }
                        }
                    }
                } else {
                    if ( INTERSECTED ) INTERSECTED.material.emissive?.setHex( INTERSECTED.currentHex );
                    INTERSECTED = null;
                    if (tooltip) tooltip.visible = false;
                }
            }
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        function onKeyDown(event) {
            if (event.key === 'c') {
                if (event.ctrlKey || event.metaKey) {
                    controls.copyState();
                }
            } else if (event.key === 'v') {
                if (event.ctrlKey || event.metaKey) {
                    controls.pasteState();
                }
            }
        }
    </script>
</body>

</html>